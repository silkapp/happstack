Happstack 0.2 Release Notes
================================================================================

  The WebT/ServerPartT change
  -------------------------------
  WebT and ServerPartT have been substantially refactored.  They are now built
  from simpler monads.  ServerPartT is now the only monad you have to deal
  with, most of the time.  I.e. you almost never have to look at WebT again.
  You just have do blocks in ServerPartT.  Inside ServerPartT you can get your
  request (askRq), modify your request (localRq), exit immediately
  (finishWith), exit failure (mzero), alter your response filters
  (composeFilter, setFilter, getFilter) and apply your responseFilters
  (applyFilter).  It also lifts ErrorT, ReaderT, WriterT and StateT, so you can
  embed one of those as well.  As a bonus, nearly all the functions you
  expected to take a WebT or to operate only within a WebT can now work inside
  a ServerPartT directly. The monad stack handles all the data threading.
  
  That being said, here are a list of the non-backwards compatible changes.
  ServerPartT, WebT, unServerPartT and unWebT now have different semantics.  To
  get existing code to compile you can change your methods like so:

    ServerPartT -> withRequest
    WebT -> mkWebT
    unServerPartT -> runServerPartT
    unWebT -> ununWebT or runWebT depending on what you're going for.

  By just making the above changes, your existing code should continue to work
  as before.  However, at this point, any old code you have can be greatly
  simplified.  For example, you will never have to use anyRequest or
  withRequest to change from ServerPartT to WebT.  You never have to interact
  with WebT directly.  You can do everything in a ServerPartT do block.  The
  examples provided in the documentation (especially basicAuth') just barely
  touch on the power of ServerPartT now.  Notice that basicAuth' mixes reading
  requests and altering responses all without exposing WebT, constructing a
  ServerPartT, or really doing any data threading at all.

  As a quick example:

  This:
    uriRest :: Monad m => (String -> ServerPartT m a) -> ServerPartT m a
    uriRest handle = withRequest $ \rq ->
                  unServerPartT (handle (rqURL rq)) rq

  Becomes this:
    uriRest :: (ServerMonad m, Monad m) => (String -> m a) -> m a
    uriRest handle = askRq >>= handle . rqURL

  Every single function that uses withRequest, anyRequest, unServerPartT,
  unWebT or ununWebT can be rewritten to take advantage of these simple monad
  behaviors.  Additionally, a lot of functions were added to make it easier to
  work entirely inside a do block.
  
    getHeaderM, addHeaderM, getData, getDataFn, escape', finishWith, getFilter,
    setFilter, composeFilter, applyFilter, setResponseCode, guardRq, methodM,
    methodOnly, nullDir

  The following were deprecated since they duplicate functionality
    
    noHandle -> Use mzero
    multi -> Use msum
    method -> you should be able to use methodSP though you'll need to fix
      your typing
    modifyResponse -> use composeFilter

  Also, this release sees the return of simpleHTTP', though not as you knew it
  before.  simpleHTTP must take a ServerPartT IO a.  simpleHTTP' lets you use
  Any ServerPartT m a, as long as you provide a function for unwrapping your
  interior monad into an IO monad.  This is particularly important since
  ServerPartT has lifting instances for WriterT, StateT, ErrorT, and ReaderT,
  thus embedding your favorite monad transformer into ServerPartT is easier
  than ever.

  Documentation
  -------------------------------
  This release also adds substantial documentation for the package
  Happstack.Server.SimpleHTTP which convers most of the new structures added,
  as well as many of your old favorites

